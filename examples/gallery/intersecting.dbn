// Intersecting shapes -- Ben Fry// random from the dbn bookset rseed 97 // not 98set bb 198621set mm 38621number random{ set bl (rseed*bb+1) set rseed (bl % mm) value (rseed % 100)}// goran's squirt functionnumber sqrt in{   set out (in/2)   repeat i 1 6 // 10   {      set out ((out + (in/out))/2)   }   value out}// blinn's sine, from the book// modified by golan and then by me// takes a number from 0 to 1000 for an angle// returns a value from -100 to 100number sin a{   set a (4*a)   set b 50   smaller? a 2000   {      smaller? a 1000      {         set t (a/10)         set t2 (t*t)         set t3 (t2*t)         set b (100-134*t2/10000+34*t3/1000000)         set b (b/2+50)      }      notsmaller? a 1000      {         set t ((2000-a)/10)         set t2 (t*t)         set t3 (t2*t)         set b (100-134*t2/10000+34*t3/1000000)         set b (50-b/2)      }   }   notsmaller? a 2000   {      smaller? a 3000      {         set t ((a-2000)/10)         set t2 (t*t)         set t3 (t2*t)         set b (100-134*t2/10000+34*t3/1000000)         set b (50-b/2)      }      notsmaller? a 3000      {         set t ((4000-a)/10)         set t2 (t*t)         set t3 (t2*t)         set b (100-134*t2/10000+34*t3/1000000)         set b (b/2+50)      }   }   value ((b - 50)*2) // return -100 to 100}number cos a{   //value <sin ((a+3000) % 4000)>   value <sin ((a+750) % 1000)>}// would be nicer to make these sort of oblongset fullRadius 10set numSticks 5//set angleStep (1000 / numSticks)// set up the angles for each stickrepeat i 1 numSticks { set <array i> ((1000*(i-1)) / numSticks)}// pre-cache the sin/cos for each radiusrepeat r 1 fullRadius{ set offset (numSticks * r * 2) repeat i 1 numSticks {  set <array (offset + i)> ((r * <cos <array i>>) / 100)  set <array (offset + numSticks + i)> ((r * (<sin <array i>> * -1)) / 100) }}// draw the starry poker fellacommand drawPokey x y rad{ pen 40 set offset (numSticks * rad * 2) set lastoff (numSticks * fullRadius * 2) repeat i 1 numSticks  {  //set ni ((i + 1) % numSticks)  set ni (i-1)  same? ni 0 ; { ; set ni numSticks ; }  set x1 (x + <array (lastoff + ni)>)  set y1 (y + <array (lastoff + numSticks + ni)>)  set x2 (<array (offset + i)> + x)  set y2 (<array (offset + numSticks + i)> + y)  line x1 y1 x2 y2 }}// setup stuff for the circleset circleSteps 25set circleStep (1000 / circleSteps)set angle 0repeat i 1 (circleSteps+1){ set <array (500+i)> ((<cos angle> * fullRadius) / 100) set <array (600+i)> ((<sin angle> * fullRadius) / 100) set angle (angle + circleStep)}command drawGumby gx gy{ pen 70 repeat i 1 circleSteps {  line (gx + <array (500+i)>) (gy + <array (600+i)>) (gx + <array (501+i)>) (gy + <array (601+i)>) }}norefreshantialias 100set pokeyX 60set pokeyY 70//set movex 0//set movey 0set mx 40set my 40//repeat radium 1 fullRadiusset radium 1forever{ paper 0 //set mx (mx + ((<random> % 5))) //set my (my + ((<random> % 5))) set mx <mouse 1> set my (<mouse 2> + 20) //smaller? mx 0 ; { ; set mx 0 ; } //smaller? my 0 ; { ; set my 0 ; } //smaller? 100 mx ; { ; set mx 100 ; } //smaller? 100 my ; { ; set my 100 ; } set dx (mx - pokeyX) //smaller? dx 0 ; { ; set dx (-dx) ; } set dy (my - pokeyY) //smaller? dy 0 ; { ; set dy (-dy) ; } set dist <sqrt ((dx*dx) + (dy*dy))> //set dist (((dx*dx) + (dy*dy)) / 200) drawGumby mx my //set radium (<sqrt dist> / 10) set radium (dist / 1) notsmaller? radium fullRadius {  set radium fullRadius } smaller? radium 1 {  set radium 1 } drawPokey pokeyX pokeyY radium pause 20 refresh}