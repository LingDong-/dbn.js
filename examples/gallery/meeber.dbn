// Meeber -- Golan Levinnorefresh//------------------------------------set bb 198621set mm 98621set seed <time 4>number random range{   set bl (seed*bb+1)   set seed (bl % mm)   value (seed % range)}number sqrt in{   set out (in/2)   repeat i 1 8   {      set out ((out + (in/out))/2)   }   value out}number abs in{   set out in   smaller? in 0   {      set out (0-in)   }   value out}number sgn in{   set out 1   smaller? in 0   {      set out (0-1)   }   value out}number sin a// blinn's sine, modified// expects a in 0...4000 !!{   set b 50   smaller? a 2000   {      smaller? a 1000      {         set t (a/10)         set t2 (t*t)         set t3 (t2*t)         set b (100-134*t2/10000+34*t3/1000000)         set b (b/2+50)      }      notsmaller? a 1000      {         set t ((2000-a)/10)         set t2 (t*t)         set t3 (t2*t)         set b (100-134*t2/10000+34*t3/1000000)         set b (50-b/2)      }   }   notsmaller? a 2000   {      smaller? a 3000      {         set t ((a-2000)/10)         set t2 (t*t)         set t3 (t2*t)         set b (100-134*t2/10000+34*t3/1000000)         set b (50-b/2)      }      notsmaller? a 3000      {         set t ((4000-a)/10)         set t2 (t*t)         set t3 (t2*t)         set b (100-134*t2/10000+34*t3/1000000)         set b (b/2+50)      }   }   value b}number cos a{   value <sin ((a+3000) % 4000)>}//------------------------------------------set scale 10000set tol (10*scale)set scale2 (4*scale)set linecolor 100set npoints  25 // 16, 20, 25, 40, 50set nptsm1 (npoints - 1)set nMitochondria 5set npoints2 (nPoints*2)set npoints3 (nPoints*3)set npoints4 (nPoints*4)//-----------------------------------------// initialize cell wallset angle 0set rad (50*scale/100)set cx (50*scale)set cy (50*scale)set da (4000/npoints)repeat q 200 400{   set <array q> (50 + <random 50>)}command init{   repeat n 1 npoints   {      set angle (angle + da)      notsmaller? angle 4000      {         set angle (angle % 4000)      }      set cosa (<cos angle>-50)      set sina (<sin angle>-50)      set x1 (cx + cosa*rad)      set y1 (cy + sina*rad)      set <array n>           x1      set <array (n+npoints)> y1   }   set nnx (cx/scale)   set nny (cy/scale)   repeat k 1 nMitochondria   {      set <array (500+k)>  (nnx + <random 10>)      set <array (600+k)>  (nny + <random 10>)      set vx <random 3>      set vy <random 3>      set <array (700+k)>  vx      set <array (800+k)>  vy      same? vx 0      {         same? vy 0         {            set k (k - 1)         }      }   }}//------------------------------------------------command doSimulation j{   set nx <array (500+j)>   set ny <array (600+j)>   set ndx <array (700+j)>   set ndy <array (800+j)>   smaller? nx 0   {      set ndx (0-ndx)      set nx (50+ <random 6>)   }   notsmaller? nx 100   {      set ndx (0-ndx)      set nx (50+ <random 6>)   }   smaller? ny 0   {      set ndy (0-ndy)      set ny (50+ <random 6>)   }   notsmaller? ny 100   {      set ndy (0-ndy)    set ny (50+ <random 6>)   }   same? [nx ny] linecolor   {      set ndx ((0 - <sgn ndx>)* (<random 3>+4)/2)      set ndy ((0 - <sgn ndy>)* (<random 3>+4)/2)      set ndxs (ndx*scale2)      set ndys (ndy*scale2)      set nxx (nx*scale)      set nyy (ny*scale)      repeat n 1 npoints      {         set px <array n>         set py <array (n+npoints)>         set sx (px - nxx)         set sy (py - nyy)         set s  (<abs sx> + <abs sy>)         smaller? s tol         {            set <array n>           (px - ndxs)            set <array (n+npoints)> (py - ndys)         }      }   }   set <array (500+j)> (nx + ndx) //nx   set <array (600+j)> (ny + ndy) //ny   set <array (700+j)> ndx   set <array (800+j)> ndy}// ----------------------------------smoothset smoothD 14set smoothD2 (smoothD - 2)command smooth{   set x0  npoints   set x1  1   set x2  2   set y0  (npoints2)   set y1  (1+npoints)   set y2  (2+npoints)   set px0 <array x0>   set py0 <array y0>   set px1 <array x1>   set py1 <array y1>   set px2 <array x2>   set py2 <array y2>   set <array x1> ((px0 + (smoothD2 *px1) + px2)/smoothD )   set <array y1> ((py0 + (smoothD2 *py1) + py2)/smoothD )   repeat n 2 nptsm1   {      set x1  n      set x0  (n-1)      set x2  (n+1)      set y1  (n+npoints)      set y0  (n+npoints-1)      set y2  (n+npoints+1)      set px0 <array x0>      set py0 <array y0>      set px1 <array x1>      set py1 <array y1>      set px2 <array x2>      set py2 <array y2>      set <array x1> ((px0 + (smoothD2 *px1) + px2)/smoothD )      set <array y1> ((py0 + (smoothD2 *py1) + py2)/smoothD )   }   set x0  nptsm1   set x1  npoints   set x2  1   set y0  (npoints+nptsm1)   set y1  (npoints2)   set y2  (1+npoints)   set px0 <array x0>   set py0 <array y0>   set px1 <array x1>   set py1 <array y1>   set px2 <array x2>   set py2 <array y2>   set <array x1> ((px0 + (smoothD2 *px1) + px2)/smoothD )   set <array y1> ((py0 + (smoothD2 *py1) + py2)/smoothD )}//------------------------------------------------initforever{   paper 40   repeat j 1 nMitochondria   {      set h1 <array (500+j)>      set v1 <array (600+j)>      field (h1-1) (v1-2) (h1+1) (v1+2) 75      field (h1-2) (v1-1) (h1+2) (v1+1) 75      set [h1 v1] 50   }   // render the cell wall from the array   smooth   set x0 (<array npoints>            /scale)   set y0 (<array (npoints+npoints)>  /scale)   pen linecolor   repeat n 1 npoints   {      set x1 (<array n>            /scale)      set y1 (<array (n+npoints)>  /scale)      set x0m1 (x0-1)      set x0p1 (x0+1)      set y0m1 (y0-1)      set y0p1 (y0+1)      set x1m1 (x1-1)      set x1p1 (x1+1)      set y1m1 (y1-1)      set y1p1 (y1+1)      line  x0    y0     x1   y1      line x0m1   y0    x1m1  y1      line x0p1   y0    x1p1  y1      line  x0    y0p1   x1   y1p1      line x0m1   y0p1  x1m1  y1p1      line x0p1   y0p1  x1p1  y1p1      line  x0    y0m1  x1    y1m1      line x0p1   y0m1  x1p1  y1m1      line x0m1   y0m1  x1m1  y1m1      set x0 x1      set y0 y1   }   // now that the wall has been drawn   repeat j 1 nMitochondria   {      doSimulation j   }   refresh   same? <mouse 3> 100   {      init   }}